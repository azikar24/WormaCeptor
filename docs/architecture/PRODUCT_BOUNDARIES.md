# WormaCeptor Product Boundaries

This document defines the scope of **WormaCeptor** to prevent feature creep and ensure architectural integrity.

## 1. Core Identity (What it IS)
**WormaCeptor is an on-device Android Network Inspection & "Man-in-the-Middle" Debugging Library.**
It is designed to help developers visualize, debug, and modify HTTP(S) traffic generated by their app *while running on the device*.

### Core Responsibilities
- **Interception:** Seamless integration with OkHttp/Retrofit stack.
- **Inspection:** Visualizing Requests and Responses (Headers, Body, Timing, Status).
- **Persistence:** Temporarily storing transaction history for debugging sessions.
- **Search:** Creating easy ways to find specific requests within a session.
- **Sharability:** Exporting transaction data (cURL, HAR, Plain Text) to external tools.

## 2. Non-Core Responsibilities (What it is NOT)
To maintain a lightweight footprint and strict focus, WormaCeptor effectively **outsources** the following domains.

### 2.1 Not a General Crash Reporter
**Anti-Pattern:** "Integrated Logcat" or "Device Snapshot" (found in Future Plans).
**Decision:** WormaCeptor should NOT attempt to replace Crashlytics, Bugsnag, or Sentry.
**Boundary:** WormaCeptor may capture crashes *directly caused by network parsing*, but generic app crashes are out of scope.

### 2.2 Not a Database/Storage Inspector
**Anti-Pattern:** "Database & SharedPreferences Inspector" (found in Future Plans).
**Decision:** Inspecting Room/SQLite/SharedPrefs is a distinct problem domain.
**Boundary:** Use Android Studio's App Inspection or generic DB inspector libraries (Search "DebugDrawer" or "Stetho").

### 2.3 Not a Production APM (Application Performance Monitor)
**Anti-Pattern:** "Network Latency Breakdown" with intent to aggregate and analyze trends.
**Decision:** WormaCeptor is for *local debugging*, not production metrics gathering.
**Boundary:** Do not add analytics SDK features (user tracking, cohort analysis, centralized dashboard).

### 2.4 Not a Complete Mock Server
**Anti-Pattern:** Complex stateful mocking logic defined on-device.
**Decision:** WormaCeptor is primarily a *viewer*. Simple static mocking is acceptable, but managing complex stateful backend logic on the phone is better handled by tools like MockWebServer or WireMock.

## 3. Extension Strategy (Plugins vs Core)
Functionality that is specific to certain technologies or integrations must be implemented as **Plugins** or **Extensions**, not in the core library.

### 3.1 Content-Type Parsers (Plugin)
The core should handle JSON/Text/XML. Everything else is an extension.
- **Protobuf/Flatbuffers:** Separate module/plugin.
- **GraphQL:** Separate module/plugin.
- **Images/Video Preview:** Separate module (to avoid adding heavy image loading libraries to core).

### 3.2 Exporters (Plugin)
The core provides the data; plugins handle the destination.
- **Jira/Slack/Trello:** Do NOT hardcode API integrations into WormaCeptor.
- **Solution:** Expose a standardized `TransactionExporter` interface.

## 4. Architectural Constraints
1.  **Zero-Dependency Core:** The `WormaCeptor-no-op` module must remain strictly empty.
2.  **Performance First:** The inspection overhead must be negligible when the UI is not active.
3.  **Sandboxed UI:** The debugger UI must not interfere with the host app's activity stack or theme (run in separate process or isolate via activity theming).
