<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>LongMethod:MemoryScreen.kt$@Composable private fun HeapUsageCard( currentMemory: MemoryInfo, isWarning: Boolean, colors: com.azikar24.wormaceptor.feature.memory.ui.theme.MemoryColors, modifier: Modifier = Modifier, )</ID>
    <ID>LongMethod:MemoryScreen.kt$@Composable private fun MemoryLineChart( history: ImmutableList&lt;MemoryInfo&gt;, colors: com.azikar24.wormaceptor.feature.memory.ui.theme.MemoryColors, modifier: Modifier = Modifier, )</ID>
    <ID>LongMethod:MemoryScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun MemoryScreen( currentMemory: MemoryInfo, memoryHistory: ImmutableList&lt;MemoryInfo&gt;, isMonitoring: Boolean, isHeapWarning: Boolean, onStartMonitoring: () -&gt; Unit, onStopMonitoring: () -&gt; Unit, onForceGc: () -&gt; Unit, onClearHistory: () -&gt; Unit, onBack: (() -&gt; Unit)?, modifier: Modifier = Modifier, )</ID>
    <ID>LongParameterList:MemoryScreen.kt$( currentMemory: MemoryInfo, memoryHistory: ImmutableList&lt;MemoryInfo&gt;, isMonitoring: Boolean, isHeapWarning: Boolean, onStartMonitoring: () -&gt; Unit, onStopMonitoring: () -&gt; Unit, onForceGc: () -&gt; Unit, onClearHistory: () -&gt; Unit, onBack: (() -&gt; Unit)?, modifier: Modifier = Modifier, )</ID>
    <ID>MagicNumber:MemoryColors.kt$MemoryColors$60f</ID>
    <ID>MagicNumber:MemoryColors.kt$MemoryColors$80f</ID>
    <ID>MagicNumber:MemoryScreen.kt$100f</ID>
    <ID>MagicNumber:MemoryScreen.kt$1_024</ID>
    <ID>MagicNumber:MemoryScreen.kt$1_024.0</ID>
    <ID>MagicNumber:MemoryScreen.kt$1_048_576</ID>
    <ID>MagicNumber:MemoryScreen.kt$1_048_576.0</ID>
    <ID>MagicNumber:MemoryScreen.kt$1_073_741_824</ID>
    <ID>MagicNumber:MemoryScreen.kt$1_073_741_824.0</ID>
    <ID>MagicNumber:MemoryScreen.kt$4</ID>
    <ID>MagicNumber:MemoryViewModel.kt$MemoryViewModel$5000</ID>
    <ID>MaxLineLength:MemoryFeature.kt$*</ID>
    <ID>UndocumentedPublicFunction:MemoryColors.kt$MemoryColors$fun statusColorForUsage(usagePercent: Float): Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val cardBackground: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val chartBackground: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val critical: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val gridLines: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val heapFree: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val heapTotal: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val heapUsed: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val labelPrimary: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val labelSecondary: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val nativeHeap: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val normal: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val valuePrimary: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryColors.kt$MemoryColors$val warning: Color</ID>
    <ID>UndocumentedPublicProperty:MemoryViewModel.kt$MemoryViewModel$// Current memory snapshot val currentMemory: StateFlow&lt;MemoryInfo&gt; = engine.currentMemory .stateIn( viewModelScope, SharingStarted.WhileSubscribed(5000), MemoryInfo.empty(), )</ID>
    <ID>UndocumentedPublicProperty:MemoryViewModel.kt$MemoryViewModel$// Heap warning indicator (when usage exceeds threshold) val isHeapWarning: StateFlow&lt;Boolean&gt; = engine.currentMemory .map { it.heapUsagePercent &gt;= MemoryMonitorEngine.HEAP_WARNING_THRESHOLD } .stateIn( viewModelScope, SharingStarted.WhileSubscribed(5000), false, )</ID>
    <ID>UndocumentedPublicProperty:MemoryViewModel.kt$MemoryViewModel$// Memory history for charts val memoryHistory: StateFlow&lt;ImmutableList&lt;MemoryInfo&gt;&gt; = engine.memoryHistory .map { it.toImmutableList() } .stateIn( viewModelScope, SharingStarted.WhileSubscribed(5000), persistentListOf(), )</ID>
    <ID>UndocumentedPublicProperty:MemoryViewModel.kt$MemoryViewModel$// Monitoring state val isMonitoring: StateFlow&lt;Boolean&gt; = engine.isMonitoring</ID>
    <ID>UnnecessaryParentheses:MemoryScreen.kt$(chartHeight / gridLineCount)</ID>
    <ID>UnnecessaryParentheses:MemoryScreen.kt$(chartWidth / (history.size - 1))</ID>
    <ID>UnnecessaryParentheses:MemoryScreen.kt$(currentMemory.nativeHeapAllocated.toFloat() / currentMemory.nativeHeapSize.toFloat())</ID>
    <ID>UnnecessaryParentheses:MemoryScreen.kt$(info.nativeHeapAllocated.toFloat() / maxMemory * chartHeight)</ID>
    <ID>UnnecessaryParentheses:MemoryScreen.kt$(info.usedMemory.toFloat() / maxMemory * chartHeight)</ID>
    <ID>UnusedParameter:MemoryColors.kt$darkTheme: Boolean = isSystemInDarkTheme()</ID>
    <ID>ViewModelInjection:MemoryFeature.kt$viewModel</ID>
  </CurrentIssues>
</SmellBaseline>
